
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module ADC_Converter(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,
	input 		          		MAX10_CLK3_50,

	//////////// KEY //////////
	input 		          		FPGA_RESET_n,
	input 		     [4:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LEDR //////////
	output		     [9:0]		LEDR,

	//////////// HEX //////////
	output		reg     [6:0]		HEX0,
	output		 reg    [6:0]		HEX1,

	//////////// Audio //////////
	inout 		          		AUDIO_BCLK,
	output		          		AUDIO_DIN_MFP1,
	input 		          		AUDIO_DOUT_MFP2,
	inout 		          		AUDIO_GPIO_MFP5,
	output		          		AUDIO_MCLK,
	input 		          		AUDIO_MISO_MFP4,
	inout 		          		AUDIO_RESET_n,
	output		          		AUDIO_SCL_SS_n,
	output		          		AUDIO_SCLK_MFP3,
	inout 		          		AUDIO_SDA_MOSI,
	output		          		AUDIO_SPI_SELECT,
	inout 		          		AUDIO_WCLK,

	//////////// QSPI Flash //////////
	inout 		     [3:0]		FLASH_DATA,
	output		          		FLASH_DCLK,
	output		          		FLASH_NCSO,
	output		          		FLASH_RESET_n,

	//////////// Power Monitor //////////
	output		          		PM_I2C_SCL,
	inout 		          		PM_I2C_SDA,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// Uart to USB //////////
	output		          		UART_RESET_n,
	input 		          		UART_RX,
	output		          		UART_TX,

	//////////// TMD 2x6 GPIO Header, TMD connect to TMD Default //////////
	inout 		     [7:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	reg  		rsp_valid;
	wire 		[4:0]cmd_channel;
	reg		cmd_sop;
	wire		cmd_eop;
	reg		cmd_rdy=1;
	wire		cmd_ready;
	wire pll100_locked;
	wire pll100_clk;
	wire pll10_locked;
	wire pll10_clk;

	reg [11:0]adc_data;
	wire rspn_valid;
	wire [11:0]rspn_data;
	wire [4:0]rspn_ch;
	wire [4:0]vlotage_value;
	reg [1:0]ready_dly_cnt=0;


//=======================================================
//  Structural coding
//=======================================================

pll100 pll100MHz(

	.inclk0(MAX10_CLK1_50),
	.c0(pll100_clk),
	.locked(pll100_locked)
	
	);
	
pll10 pll10MHz(

	.inclk0(pll100_clk),
	.c0(pll10_clk),
	.locked(pll10_locked)
	
	);



anain2_converter u0(
	.modular_adc_0_adc_pll_locked_export(pll10_locked),
	.modular_adc_0_adc_pll_clock_clk(pll10_clk),
	.modular_adc_0_reset_sink_reset_n(KEY[0]),
	.modular_adc_0_clock_clk(pll10_clk),

	
	.modular_adc_0_command_valid(pll10_locked),
	.modular_adc_0_command_channel(0),
	.modular_adc_0_command_ready(1'b1),
	
	.modular_adc_0_response_valid(rspn_valid),

	.modular_adc_0_response_channel(rspn_ch),
	.modular_adc_0_response_data(rspn_data)
	
	);	
	

	
	
always@(posedge pll10_clk)begin
	
	if (rspn_valid) begin
		ready_dly_cnt=ready_dly_cnt+1;
		if(ready_dly_cnt==0)begin
			if(cmd_rdy) begin
				cmd_rdy <= 0;
			end
			else begin 
				cmd_rdy <= 1;
			end
		end
	end

		
		
		
 end

 assign cmd_ready= cmd_rdy;
 

	
	




	

	

	

	always@(posedge pll10_clk)
		if (rspn_valid && rspn_ch == 0)
			adc_data <= rspn_data;


	
	assign vlotage_value = adc_data / 163;
	
	wire [6:0]value0 = 7'b1000000;
	wire [6:0]value1 = 7'b1111001;
	wire [6:0]value2 = 7'b0100100;
	wire [6:0]value3 = 7'b0110000;
	wire [6:0]value4 = 7'b0011001;
	wire [6:0]value5 = 7'b0010010;
	wire [6:0]value6 = 7'b0000010;
	wire [6:0]value7 = 7'b1011000; //
	wire [6:0]value8 = 7'b0000000;
	wire [6:0]value9 = 7'b0010000;
	
	always@(*)
	 begin
		case (vlotage_value)
			0:
				begin
					HEX0 = value0;
					HEX1 = value0;
				end
			1:
				begin
					HEX0 = value1;
					HEX1 = value0;
				end
			2:
				begin
					HEX0 = value2;
					HEX1 = value0;
				end
			3:
				begin
					HEX0 = value3;
					HEX1 = value0;
				end
			4:
				begin
					HEX0 = value4;
					HEX1 = value0;
				end
			5:
				begin
					HEX0 = value5;
					HEX1 = value0;
				end
			6:
				begin
					HEX0 = value6;
					HEX1 = value0;
				end
			7:
				begin
					HEX0 = value7;
					HEX1 = value0;
				end
			8:
				begin
					HEX0 = value8;
					HEX1 = value0;
				end
			9:
				begin
					HEX0 = value9;
					HEX1 = value0;
				end
			10:
				begin
					HEX0 = value0;
					HEX1 = value1;
				end
			11:
				begin
					HEX0 = value1;
					HEX1 = value1;
				end
			12:
				begin
					HEX0 = value2;
					HEX1 = value1;
				end
			13:
				begin
					HEX0 = value3;
					HEX1 = value1;
				end
			14:
				begin
					HEX0 = value4;
					HEX1 = value1;
				end
			15:
				begin
					HEX0 = value5;
					HEX1 = value1;
				end
			16:
				begin
					HEX0 = value6;
					HEX1 = value1;
				end
			17:
				begin
					HEX0 = value7;
					HEX1 = value1;
				end
			18:
				begin
					HEX0 = value8;
					HEX1 = value1;
				end
			19:
				begin
					HEX0 = value9;
					HEX1 = value1;
				end
			20:
				begin
					HEX0 = value0;
					HEX1 = value2;
				end
			21:
				begin
					HEX0 = value1;
					HEX1 = value2;
				end
			22:
				begin
					HEX0 = value2;
					HEX1 = value2;
				end
			23:
				begin
					HEX0 = value3;
					HEX1 = value2;
				end
			24:
				begin
					HEX0 = value4;
					HEX1 = value2;
				end
			25:
				begin
					HEX0 = value5;
					HEX1 = value2;
				end
		
			default:
				begin
					HEX0 = value0;
					HEX1 = value0;
				end
		endcase
	 end
	



endmodule
